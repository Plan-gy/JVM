java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能指一个前端编译期(编译期的前端)
把*.java文件转变成*.class文件的过程；也可能是指虚拟机的后端运行期编译期(JIT编译期)直接把字节码转变为机器码的过程；也可能是指使用静态提前编译期(AOP编译期)直接把*.java文件编译成本地机器代码的过程。
前端编译器：Sun的javac，Eclipse JDT中的增量式比那一起(ECJ)
JIT编译器：HotSpot VM 的c1,c2编译器
AOT编译器：GNU Compiler for the java，Excelsior JET。
10.2javac编译器
Sun javac编译过程：
	• 解析与填充符号表过程
	• 插入式注解处理器的注解处理过程
	• 分析与字节码生成过程




javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类
10.2.2解析与填充符号表
	1. 词法，语法分析 (parseFiles()过程)
词法分析是将源代码的字符流转变为标记集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字，变量名，字面量，运算符都可以成为标记，在javac的源码中，词法分析过程是由com.sun.tools.javac.parser.Scanner类实现。
语法分析是根据Token序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点代表着程序代码的一个语法结构，如包，类型，修饰符等
	2. 填充符号表(enterTrees())
符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到。
在语法分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标diamante生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。在javac的源码中，填充符号过程是由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表，包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java(如果存在的话)的顶级节点
10.2.3注解处理器
JDK1.5后，提供了注解的支持。都是在运行期间发挥作用的。
可以看做是一组编译器的插件，在这些插件里面，可以读取，修改，添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有在对语法树进行修改位置，每一次循环成为一个Round，在javac的源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，执行过程是在processAnnotations()方法中完成，这个方法判断是否还有新的注解处理器需要执行，如果有，通过com.sun..tools.javac.processing.JavacProcessingEnvironment类的doProcessing()产生一个新的javaCompiler对象对编译的后序步骤进行处理。
10.2.4语义分析与字节码生成
语法树能够表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语法分析的主要任务是对结构上正确 的源程序进行上下文有关性质的审查。
	1. 标注检查
	语义分析过程分为标注检查以及数据及控制流分析两个阶段。分别由attribute(),flow()方法完成
	标注检查步骤检查的内容包括诸如变量使用前是否已被声明，变量与复制之间的数据类型是否能够匹配等。标注检查会发生常量折叠的动作。
	标注检查步骤在javac源码的实现类时com.sun.tools.javac.comp.Atrr类和Check类(comp下)
	2. 数据及控制流分析
	是对程序上下文逻辑进一步的验证，可以检查出诸如陈旭局部变量在使用前是否被赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了等问题。
	将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期保障。
	在javac源码中，数据及控制流分析的入口是flow方法，具体操作是comp.flow类来完成
	3. 解语法糖
	称为糖衣语法，指在计算机语言 中添加某种语法，这种语法对语言的功能并没有影响，但方便使用
	可以增加程序的可读性，从而减少程序代码出错的机会。
	java中最常用的语法糖主要是泛型，变长参数，自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还原会简单的基础语法结构，这个过程称为解语法糖，在javac源码中，解语法糖的过程有desugar方法触发，在comp.TransTypes类和comp.Lower类中完成。
	4. 字节码生成
	在javac源码中由com.sun.tools.javac.jvm.Gen类完成，字节码生成阶段不仅仅是把前面各个步骤所生成的信息转换成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。
	实例构造器<init>()和类构造器<cinit>()的产生过程实际是一个代码收敛的过程，编译器会把语句块(对于实例构造器是“{}”，对于类构造器是“static{}”)，变量初始化，调用父类的实例构造器等操作收敛到<init>()和<cinit>()方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行。
完成了对语法树的遍历，就会把填充了所有信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass方法输出字节码，生成最终的Class文件。

解析与填充符号表		注解处理		分析与字节码生成		0101…

10.3java语法糖的味道
10.3.1泛型与类型擦除
泛型是JDK1.5的一项新增特性,本质是参数化类型的应用,也就是所操作的数据类型被指定为一个参数。
C#里面泛型无论在程序源码中，编译后的IL中，或是运行期的CLR中，都是切实存在的List<int>和List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据。这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型
java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了，并且在相应的地方插入了强制转型代码，因此对于运行期的java语言来说，ArrayList<int>和ArrayList<String>就是同一个类，所以泛型技术实际上就是java语言的一刻语法糖，java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
泛型擦除成相同的原生类型只是无法重载的器重你一部分原因。
Signature是其中最重要的一项属性，作用：存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。
擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际撒花姑娘元数据中还是保留了泛型信息，这也是我们能通过反射取得参数化类型的根本依据。
10.3.2自动装箱，拆箱与遍历循环
自动装箱，拆箱子啊编译之后被转化为了对应的包装和还原方法。而遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环要被遍历的类实现Iterable接口的原因。边长参数，在调用的时候编程了一个数组类型的参数。
10.3.3条件编译
java语言当然可以进行条件编译，方法就是使用条件为常量的if语句。如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，拒绝编译。
