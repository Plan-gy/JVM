12.2硬件的效率与一致性
由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。
缓存一致性：每一个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务设计到主内存时，可能数据不同，最终同步数据到主内存时以谁的缓存数据为主？
为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱码执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致，但并不保证程序中各个语句计算的先后顺序一致。

12.3java内存模型
java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。
内存模型必须定义的足够严谨，才能让java的并发内存访问操作不会产生歧义，但是，也必须定义的足够宽松，是的虚拟机的实现有足够的自由空间去利用硬件的各种特性来获取更好的执行速度。

12.4主内存与工作内存
java内存模型的主要目的是定义程序中各个变量的访问规则，及在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。变量包括了实例字段，静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的不会被共享。为了获取更好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。
java内存模型规定了所有变量都存储在主内存中，每个线程有自己的工作内存，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递依赖主内存完成




12.3.2内存间交互操作
虚拟机保证下面的操作是原子的，不可再分的
	• Lock锁定：作用于主内存的变量，它把一个变量标识为一条线程独占的状态
	• unlock解锁：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
	• Read读取：作用于主内存的变量，它把一个变量的值从主内存传输到线程的各种内存中，便于后面的load动作使用。
	• Load 载入：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
	• Use使用：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
	• Assign赋值：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行这个操作。
	• Store存储：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中，便于后面的write操作使用
	• write写入：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
如果要把一个变量从主内存复制到工作内存中，要顺序执行read和load。如果要把变量从工作内存同步回主内存，就要顺序执行store和write操作。只保证顺序执行，不保证连续执行
这8中基本操作要满足一下规则
	• 不允许read和load，store和write操作之一单独出现。
	• 不允许一个线程丢弃它的最近的assign操作。在工作内存中改变后要同步到主内存中。
	• 不允许一个线程无原因的把数据从线程的工作内存同步到主内存中
	• 一个新的变量只能在主内存中产生，不允许在工作内存中直接使用一个未被初始化的变量。
	• 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
	• 如果对一个变量执行lock操作，哪将会清空工作内存中此变量的值，在执行引擎使用这个变量前，要重新执行load或assign操作初始化变量的值
	• 如果一个变量事先没有被lock操作锁定，就不允许对它执行unlock操作
	• 对一个变量执行unlock操作前，必须先把此变量同步回主内存中。((store,write)
12.3.3对于volatile型变量的特殊规则
关键字volatile可以说是java虚拟机提供的最轻量级的同步机制。
当一个变量是volatile之后，有两种特性：1、保证此变量对所有线程的可见性，这里的“可见性”指的是当一条线程修改了这个变量的值，新值对于其他线程来说是立刻知道的。
java里面的运算不是原子性的，所以导致volatile变量的运算在并发下一样是不安全的。
分析字节码后发现：volatile只能保证此刻这个线程取得的数据是同一个，但是操作数据并返回有时间差，不一定先执行的就先返回，所以多线程下就会导致同步回主内存的数据不一定正确。
由于volatile变量只能保证可见性，在不符合下面两条规则还是要通过加锁来保证原子性
加锁(使用synchronized或java.util.concurrent中的原子类)
	1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量值
	2. 变量不需要与其他的状态变量共同参与不变约束。
2、禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到争取的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
只有一个CPU访问内存时，并不需要内存屏障，有多个CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。
volatile变量读操作的性能消耗与普通变量几乎没什么差别，但是写操作可能会慢点，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。
java内存模型对volatile变量定义的特殊规则


12.3.4对于long和double型变量的特殊规则
虚拟机允许实现选择可以不保证64位数据类型的load，store，read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定。
12.3.5原子性，可见性，有序性
原子性：由java内存模型来直接保证的原子性变量操作包括read，load，assign，use，store，write，基本数据类型的访问读写是具备原子性的(例外就是long和double的非原子性协议)
在synchronized块之间的操作也是具有原子性的
可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
volatile，final，synchronized实现了可见性。
有序性：如果在本线程内观察，所有操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的。volatile，synchronized保证线程之间操作的有序性。
12.3.6先行发生原则(happen-before)
这个原则是判断数据是否存在竞争，线程是否安全的主要依据。
先行发生是java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说操作A产生的影响能被操作B观察到，影响：修改内存中共享变量的值，发送消息，调用方法等
下列的的先行发生关系无序任何同步器协助就存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法推导出，就没有顺序保障，虚拟机可以对它们随意进行重排序。
	• 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确来说应该控制流顺序而不是程序代码顺序，因为要考虑分支，循环等结构
	• 管程锁定规则：对于一个volatile变量的写操作先行发生于后面对这个变量的读操作。后面：是指时间上的先后顺序
	• volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，后面：是指时间上的先后顺序。
	• 线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作
	• 线程终止规则：线程中所有操作都先行发生于对此线程的终止检测，
	• 线程中断规则：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()检测是否中断。
	• 对象终结规则：一个对象的初始化完成先行发生于它的finalize方法的开始
	• 传递性：A先行于B，B先行于C，则A先行于C
时间先后顺序与先行发生原则之间基本没有太大关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。

java线程		工作内存

java线程		工作内存		save和Load操作		主内存

java线程		工作内存

线程，主内存，工作内存三者的交互关系

12.4java与线程
12.4.1线程的实现
线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和调度分开，各个线程既可以共享进程资源，又可以独立调度。
实现线程的3种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现
	1. 使用内核线程实现
	内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
	每个内核线程视为内核的一个分身，支持多线程的内核就叫做多线程内核。
	程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口-轻量级进程(LWP)
	先支持内核线程，才与轻量级进程。轻量级进程和内核线程之间1:1关系称为一对一线程模型。
	限制：由于是基于内核线程实现的，所以各种操作都需要进行系统调用。而系统调用需要在用户态和内核态来回切换，其次，轻量级线程要消耗一定的内核资源，因此是有限的
	2. 使用用户线程实现
	轻量级线程也属于用户线程，但是轻量级线程始终是建立在内核上的，效率受到限制。
	狭义的用户线程是指完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。
	用户线程的建立，同步，销毁和调度完全在用户态中完成，操作非常快速，低消耗，支持大规模的线程数量。这种进程与用户线程之间1:N的关系称为一对多的线程模型。
	3. 使用用户线程加轻量级进程混合实现
	用户线程还是完全建立在用户空间中，因此用户线程的创建，切换，析构等操作依然廉价，并且可以支持大规模的用户线程并发。在这种混合模式下，用户线程和轻量级进程的数量比是不定的
	N:M，这种就是多对多的线程模型。
	4. java线程的实现
	java线程在JDK1..2之前是基于绿色线程的用户线程实现，在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现。
12.4.2java线程调度
系统为线程分配处理器使用权的过程，主要有调度方式有两种：协同式线程调度,抢占式线程调度。
协同式调度：线程的执行时间由线程本身来控制，线程自己工作完成后，通知切换到另一个线程。
好处：实现简单，切换是可知的。坏处：程序执行时间不可控制，不稳定
抢占式线程调度：每个线程由系统来分配执行时间，线程的切换不由线程本身来决定。
可以给一些线程多分配一点执行时间，由优先级控制，但是不是很靠谱，最终还是取决于操作系统。

12.4.3状态转换
java语言新建了5中线程状态
	• 新建：创建后尚未启动的线程处于这种状态
	• 运行：Runnable包括了操作系统线程状态中的running和ready，就是说这个线程状态的线程可能正在执行，可能在等待CPU分配执行时间
	• 无限期等待：不会被分配时间，等待被其他线程显式唤醒
		没有设置Timeout参数的Object.wait()
		没有设置Timeout参数的Thread.join()
		LockSupport.park()
	• 限期等待：不会被分配时间，不过无需等待被其他线程显式唤醒，一段时间会系统自动唤醒。
		Thread.sleep()
		设置Timeout参数的Object.wait()
		设置Timeout参数的Thread.join()
		LockSupport.parkNanos()
		LockSupport.parkUntil()
	• 阻塞：阻塞与等待的区别：阻塞在等待着获得一个排它锁，这个事件发生在另外一个线程放弃这个锁的时候，而等待则是等待一段时间，或者唤醒动作的发生，程序等地啊进入同步区域，将进入这种状态。
	• 结束：终结线程的状态，线程结束执行
