    		虚拟机字节码执行引擎
	执行引擎是java虚拟机最核心的组成部分之一。虚拟机是有一个相对于物理机的概念，这两种机器都有
代码执行能力，区别是物理机的执行引擎是直接建立在处理器，硬件，指令集和操作系统层面上的，而虚拟机的执行引擎则是自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接直接支持的指令集格式。
从外观上看起来所有的java虚拟机的执行引擎都是一直的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。在不同的虚拟机实现里面，执行引擎在执行java代码的时候可能会有解释执行和编译执行两种选择，也坑你两者兼备。

8.2运行时栈帧结构
栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。
每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经确定了，并且写入到方法表的Code属性之中，栈帧的内存大小取决于具体的虚拟机实现，而不是程序运行期变量数据的影响。
对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。
8.2.1局部变量表(Local Variable Table)
是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
在java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了LVT需要分配的最大容量
局部变量表的容量以变量槽为最小单位(Variable Slot)，一个Slot可以存放boolean,byte,char,short,int,float,reference,returnAddress类型的数据,这8种数据类型都可以使用32位或者更小的物理内存来存放。允许Slot的长度可以随着处理器，操作系统或虚拟机的不同而发生变化，只要保证及时在64位虚拟机中使用64位物理内存实现Slot，虚拟机让要使用对齐和补白的手段让Slot看起来和32位虚拟机
一致。
reference类型表示对一个对象实例的引用，虚拟机没有说明他的长度，也没有明确值出这种引用是什么结构
一般来说，虚拟机实现至少要能够通过这个引用做到两点：第一是从此引用中直接或间接的查找到对象在java堆中的数据存放的起始地址索引，二是此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现java语言规范中定义的语法约束。
returnAddress类型是为字节码指令jsr，jsr_w,ret服务的，指向了一条字节码指令的地址。
对于64位的数据类型，虚拟机会一高位对齐的方式为其分配两个连续的Slot空间，不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否是原子操作，都不会引起数据安全问题。
虚拟机通过索引定位的方式使用局部变量表，索引值从0到变量表最大的Slot数量，32位数据类型变量，n就表示了使用第n个Slot，64位数据的变量，则说明同时使用n和n+1两个Slot，对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个。
方法执行时，虚拟机使用局部变量表完成参数值到参数变量列表的传递过程，如果是实例方法，哪第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问这个隐含的参数。
为了尽可能的节省镇站空间，局部变量表中的Slot可以重用，方法体中定义的变量，其作用域并不一定覆盖整个方法体，如果当前字节码PC计数器的值超出了某个变量的作用域，哪这个变量对应的Slot可以交给其他变量
变量能否被回收的根本原因是：局部变量表中的Slot是否还存在关于变量对象的引用。
如果遇到一个方法，其后面的代码由一些耗时很长的操作，而前面有定义了占用了大量内存，实际上已经不会再使用的变量，手动将其设置为null值，这中操作可以作为一种在级特殊情形下来使用(对象占用内存大，此方法的栈帧长时间不能被回收，方法调用次数达不到JIT的编译条件)
不应当对赋null值操作过多依赖：从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法，从执行角度讲，使用赋null值操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的
类变量有两次赋初始值的过程，1是在准备阶段，赋予系统初始值，二外是在初始化阶段，赋予定义的初始值
局部变量不一样，如果一个局部变量定义了没有赋初始值是不能使用的。
8.2.2操作数栈
常称为操作栈，是一个后入先出栈。操作数栈的最大深度也子啊编译的时候写入到Code属性的max_stacks中
操作数栈的每一个元素可以是任意的java数据类型，包括long和double，
32位数据类型所占的栈容量为1,64位数据类型所占的占容量为2,在执行任何时候，操作栈不会超过设置最大值
操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要验证这一点。
在概念模型中，两个栈帧作为虚拟机栈的元素，是完全独立的，但在大多数虚拟机的实现中都会做一些优化处理，另两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈和尚明栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无需进行额外的参数赋值传递。
8.2.3动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用就是为了支持动态连接
符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化成为静态解析，另外一部分将会在每一次运行期间转化为直接引用，这部分成为动态连接。
8.2.4方法返回地址
当一个方法开始执行后，只有两种方式可以退出方法：第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据何种方法返回指令来决定，这中退出方法的方式成为正常完成出口。另外一种方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种方式称为异常完成出口。
无论哪种返回方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回是可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。
方法退出的过程实际上就等同于把当前栈帧出栈，退出可能执行的操作：恢复上层方法的局部变量表和操作数栈，把返回值压入滴啊用着栈帧的操作数栈中，调整PC计数器的值以指向方法调用执行指令后面的一条指令。

8.3方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(及调用哪一个方法)，暂时还不涉及方法内部的具体运行过程。
一切方法调用在Class文件里面存储的都是符号引用，而不是实际运行时内存布局中的入口地址。、
8.3.1解析
在类加载的解析阶段，会将一部分符号引用转化为直接引用，解析成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的。这类方法的调用称为解析。
符合“编译器可知，运行期不可变”的方法主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了他们不可能通过别的方式重写其他版本，因此他们都适合在类加载阶段进行解析，在java虚拟机中提供了5条方法调用字节码指令
Invokestatic:调用惊天方法
Invokespecial:调用实例构造器<init>方法，私有方法和父类方法
Invokevirtual:调用所有的虚方法
Invokeinterface:调用接口方法，会在运行时在确定一个实现接口的对象
Invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后在执行该方法，在次之前的4条调用指令，分派逻辑是固化在java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。
只要能被invokestatic,invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法，私有方法，实例构造器，父类方法这4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法称为非虚方法，其他方法称为虚方法。非虚方法还有一种就是final修饰的方法。
解析调用一定是一个静态的过程，在编译期间就完全确定的，在类装载的解析阶段就会把设计的符号引用全部转变为可确定的直接引用，不会延迟到运行期在去完成。而分派调用则可能是静态的可能是动态的，根据分派的宗量数可分为单分派和多分派。这两类分派组合构成静态单分派，惊天多分派，动态单分派，动态多分派。
8.3.2分派
java具备面向对象的3个基本特征：继承，封装，多态
	1. 静态分派
Human称为变量的讲台类型，或者外观类型，Man称为变量的实际类型。
两个在程序中都发生了一些变化
静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型时在编译器可知的
而实际类型变化的结果在运行期才可以确定，编译器在编译程序的时候并不知道一个对象的实际类型时什么。
使用哪个重载版本，就完全取决于传入参数的数量和数据类型。虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据的。
所有依赖静态类型来定位方法执行版本的分派动作成为静态分派。讲台分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。
字面量不需要定义，所以字面量没有显式的静态类型。实际上自动转型还能继续发生多次，按照char->int->long->float->double->自动装箱的类->序列化Serializable->Object->变长参数的顺序转型进行匹配，但不会匹配到byte和short类型的重载，因为char到byte和short的转型是不安全的。自动装箱的类实现了序列化，
找不到装箱类就找装箱类实现的接口类型，Charcter实现了Serializable和Comparable，这时候就会提示类型模糊，拒绝编译，除非在调用时显式的指定字面量的静态类型。
如果有多个父类，哪将在继承关系中从下到上开始搜索，越接近上层的优先级越低，变长参数的重载优先级最低。
	2. 动态分派
动态与多态性的另外一个重要体现--重写有关联。
对象是将要执行的方法的所有者称为接收者。
invokevirtual指令的运行时解析过程
	1找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C
	2如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验， 如果通过则返回这个方法的直接引用，查找结束，如果不通过，则返回java.lang.IllegalAccessErroe异常。
	3否则，按照继承关系从下往上一次对C的各个父类进行第二步的搜索和验证。
	4如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError
由于invokevirtual指令执行的第一步就是在运行期确定接搜着的实际类型，所以两次调用中断invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是java语言中方法重写的本质
	3. 单分派与多分派
单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择
因为根据两个宗量进行选择，所以java预言的静态分派属于多分派类型
因为只有一个宗量作为选择依据，所以java语言的动态分挨批是单分派类型
现在的java语言是：静态多分派，动态单分派的语言
	4. 虚拟机动态分派的实现
稳定优化：
在类方法区中建立一个虚方法表，也称为vtable，在invokeinterface执行时也会用到接口方法表--Interface Method Table ，使用虚方法表索引来代替元数据查找来提高性能。虚方法表存放这各个方法的实际入口地址
如果子类没重写父类方法，哪子类的入口地址与父类相同，如果重写，哪入口地址指向了子类实现版本的地址
 方法表一般在列加载的连接阶段进行初始化，准备了类的变量初始化后，虚拟机会把该类的方发表初始化。
8.3.3动态类型语言支持
动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器。
“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个重要特征。
JDK1.7之前的字节码指令集中，4条方法调用指令的第一个参数都是被调用的方法的符号引用(CONSTANT_Method_info,CONSTANT__InterfaceMethodref_info常量)，方法符号引用在编译时产生，而动态类型语言只有在运行期才能确定接受者类型。
JDK1.7实现了JSR-292,新加入的java.lang.incoke包就是其的一个重要组成部分。主要目的是在之前单纯依靠符号引用来确定目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为MethodHandle。
MethodHandle的使用方法和Reflection的区别
	• 从本质上讲，Refleciton和MethodHandle机制都是在模拟方法调用，但Reflection是子啊模拟java代码层次的方法调用，而methodHandle是在模拟字节码层次的方法调用。
	• Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息多。前者是方法在java一端的全面映像，而后者仅仅包含与执行该方法相关的信息。
	• 由于MethodHandle是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的各种优化，在MethodHandle上也应当可以采用类似思路去支持，而通过反射去调用则不行。
	• Reflection API的设计目标是只为java语言服务的，而MethodHandle则设计成可服务于所有java虚拟机之上的语言，其中包括java语言
Invokedynamic指令
每一处含有invokedynamic指令的位置都称为动态调用点，这条指令的第一个参数不在是代表方法符号引用的CONSTANT__InterfaceMethodref_info常量，而是变为JDK1.7新加入的CONSTANT__INvokeDynamic_info常量，从这个常量可以得到：引导方法，方法类型和名称。
掌握方法分派规则
invokedynamic指令与前面四个的最大差别就是它的分派逻辑不是由虚拟机决定的，而是程序员决定

8.4基于栈的字节码解释执行引擎
8.4.1解释执行
虚拟机大多遵循这种基于现代经典编译原理的思路










java语言中，javac编译器完成了程序代码经过词法分析，语法分析到抽象语法树，在遍历语法树申城现行的字节码指令流的过程。
8.4.2基于栈的指令集与基于寄存器的指令集
java编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是领地址指令，它们依赖于操作数栈进行工作。
基于栈的指令集主要优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免的要收到硬件的约束。栈架构指令集的主要缺点是执行速度相对来说会稍微面一点。
8.4.3基于栈的解释器执行过程
bipush指令作用：将单字节的整数常量推入操作数栈顶
istore指令的作用是操作数栈顶的整型值出栈存放到第一个局部变量Slot中
iload作用是将局部变量表Slot中的整型值复制到操作数栈顶。
