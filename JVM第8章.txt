    		虚拟机字节码执行引擎
	执行引擎是java虚拟机最核心的组成部分之一。虚拟机是有一个相对于物理机的概念，这两种机器都有
代码执行能力，区别是物理机的执行引擎是直接建立在处理器，硬件，指令集和操作系统层面上的，而虚拟机的执行引擎则是自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接直接支持的指令集格式。
从外观上看起来所有的java虚拟机的执行引擎都是一直的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。在不同的虚拟机实现里面，执行引擎在执行java代码的时候可能会有解释执行和编译执行两种选择，也坑你两者兼备。

8.2运行时栈帧结构
栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。
每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经确定了，并且写入到方法表的Code属性之中，栈帧的内存大小取决于具体的虚拟机实现，而不是程序运行期变量数据的影响。
对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。
8.2.1局部变量表(Local Variable Table)
是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
在java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了LVT需要分配的最大容量
局部变量表的容量以变量槽为最小单位(Variable Slot)，一个Slot可以存放boolean,byte,char,short,int,float,reference,returnAddress类型的数据,这8种数据类型都可以使用32位或者更小的物理内存来存放。允许Slot的长度可以随着处理器，操作系统或虚拟机的不同而发生变化，只要保证及时在64位虚拟机中使用64位物理内存实现Slot，虚拟机让要使用对齐和补白的手段让Slot看起来和32位虚拟机
一致。
reference类型表示对一个对象实例的引用，虚拟机没有说明他的长度，也没有明确值出这种引用是什么结构
一般来说，虚拟机实现至少要能够通过这个引用做到两点：第一是从此引用中直接或间接的查找到对象在java堆中的数据存放的起始地址索引，二是此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现java语言规范中定义的语法约束。
returnAddress类型是为字节码指令jsr，jsr_w,ret服务的，指向了一条字节码指令的地址。
对于64位的数据类型，虚拟机会一高位对齐的方式为其分配两个连续的Slot空间，不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否是原子操作，都不会引起数据安全问题。
虚拟机通过索引定位的方式使用局部变量表，索引值从0到变量表最大的Slot数量，32位数据类型变量，n就表示了使用第n个Slot，64位数据的变量，则说明同时使用n和n+1两个Slot，对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个。
方法执行时，虚拟机使用局部变量表完成参数值到参数变量列表的传递过程，如果是实例方法，哪第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问这个隐含的参数。
为了尽可能的节省镇站空间，局部变量表中的Slot可以重用，方法体中定义的变量，其作用域并不一定覆盖整个方法体，如果当前字节码PC计数器的值超出了某个变量的作用域，哪这个变量对应的Slot可以交给其他变量
变量能否被回收的根本原因是：局部变量表中的Slot是否还存在关于变量对象的引用。
如果遇到一个方法，其后面的代码由一些耗时很长的操作，而前面有定义了占用了大量内存，实际上已经不会再使用的变量，手动将其设置为null值，这中操作可以作为一种在级特殊情形下来使用(对象占用内存大，此方法的栈帧长时间不能被回收，方法调用次数达不到JIT的编译条件)
不应当对赋null值操作过多依赖：从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法，从执行角度讲，使用赋null值操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的
类变量有两次赋初始值的过程，1是在准备阶段，赋予系统初始值，二外是在初始化阶段，赋予定义的初始值
局部变量不一样，如果一个局部变量定义了没有赋初始值是不能使用的。
8.2.2操作数栈
常称为操作栈，是一个后入先出栈。操作数栈的最大深度也子啊编译的时候写入到Code属性的max_stacks中
操作数栈的每一个元素可以是任意的java数据类型，包括long和double，
32位数据类型所占的栈容量为1,64位数据类型所占的占容量为2,在执行任何时候，操作栈不会超过设置最大值
操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要验证这一点。
在概念模型中，两个栈帧作为虚拟机栈的元素，是完全独立的，但在大多数虚拟机的实现中都会做一些优化处理，另两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈和尚明栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无需进行额外的参数赋值传递。
8.2.3动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用就是为了支持动态连接
符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化成为静态解析，另外一部分将会在每一次运行期间转化为直接引用，这部分成为动态连接。
8.2.4方法返回地址
当一个方法开始执行后，只有两种方式可以退出方法：第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据何种方法返回指令来决定，这中退出方法的方式成为正常完成出口。另外一种方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种方式称为异常完成出口。
无论哪种返回方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回是可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。
方法退出的过程实际上就等同于把当前栈帧出栈，退出可能执行的操作：恢复上层方法的局部变量表和操作数栈，把返回值压入滴啊用着栈帧的操作数栈中，调整PC计数器的值以指向方法调用执行指令后面的一条指令。

8.3方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(及调用哪一个方法)，暂时还不涉及方法内部的具体运行过程。
一切方法调用在Class文件里面存储的都是符号引用，而不是实际运行时内存布局中的入口地址。、
8.3.1解析
在类加载的解析阶段，会将一部分符号引用转化为直接引用，解析成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的。这类方法的调用称为解析。
符合“编译器可知，运行期不可变”的方法主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了他们不可能通过别的方式重写其他版本，因此他们都适合在类加载阶段进行解析，在java虚拟机中提供了5条方法调用字节码指令
Invokestatic:调用惊天方法
Invokespecial:调用实例构造器<init>方法，私有方法和父类方法
Invokevirtual:调用所有的虚方法
Invokeinterface:调用接口方法，会在运行时在确定一个实现接口的对象
Invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后在执行该方法，在次之前的4条调用指令，分派逻辑是固化在java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。
只要能被invokestatic,invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法，私有方法，实例构造器，父类方法这4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法称为非虚方法，其他方法称为虚方法。非虚方法还有一种就是final修饰的方法。
解析调用一定是一个静态的过程，在编译期间就完全确定的，在类装载的解析阶段就会把设计的符号引用全部转变为可确定的直接引用，不会延迟到运行期在去完成。而分派调用则可能是静态的可能是动态的，根据分派的宗量数可分为单分派和多分派。这两类分派组合构成静态单分派，惊天多分派，动态单分派，动态多分派。
8.3.2分派
java具备面向对象的3个基本特征：继承，封装，多态
	1. 静态分派
Human称为变量的讲台类型，或者外观类型，Man称为变量的实际类型。
