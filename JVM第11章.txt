当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为热点代码。为了提高热点代码的
效率，在运行时，虚拟机将会吧这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成任务的编译器称为即时编译器(JIT)。
11.2HotSpot虚拟机内的即时编译器
	• 为何HotSpot虚拟机要使用解释器与编译器并存的架构
	• 为何HotSpot虚拟机要实现两个不同的即时编译器
	• 程序何时使用解释器执行？何时使用编译器执行？
	• 那些程序代码会被编译为本地代码？如何编译为本地代码？
	• 如何从外部观察及时编译器的编译过程和编译结果？
11.2.1解释器与编译器
解释器与编译器各有优点;当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，繁殖可以使用编译执行来提高效率。








HotSpot虚拟机内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称C1,C2.
无论采用的编译器是哪个，解释器与编译器搭配使用的方式在虚拟机中称为混合模式，用户可以使用参数“-Xint”强制虚拟机运行与解释模式，这时候编译器完全不介入工作，全部diamante由解释方式执行。
或者使用参数“-Xcomp”强制虚拟机处于“编译模式”，使用“-version”显示着三种模式
为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译的策略，
分层编译根据编译器编译，优化的规模与耗时，划分出不同的编译层次
	• 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译
	• 第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑
	• 第2层（或2层以上），称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。
实行分层编译后，Client Compiler 和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Complier获取更高的编译速度，用Server Compiler类获取更好的编译指令，在解释执行的时候也无序在承担收集性能监控信息的任务。
11.2.2编译对象与触发条件
有两类被即时编译器编译的热点代码：被多次调用的方法，被多次执行的循环体。
对于第一种情况,由于是由方法调用触发的编译,因此编译器理所当然的会一整个方法作为编译对象,这种编译也是虚拟机中标准的JIT编译方式.对于后一种情况,尽管编译动作是由循环体所触发的,但编译器依然会以整个方法作为编译对象.这种编译方式因为编译发生在方法执行过程中,因此形象的称为栈上替换(OSR)
判断一段代码是不是热点代码，是不是需要出发即时编译，这样的行为成为热点探测，
	• 基于采样的热点探测：采用这种方法的虚拟机会周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，哪这个方法就是热点方法。
	• 基于计数器的热点探测：虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为是热点方法。
在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测，因此他为每个方法准备了两类计数器：方法调用计数器和回边计数器，都有确定的阈值，当计数器超过阈值，就会触发JIT编译。
方法调用计数器：默认值：Client 1500   Server  10000 通过-XX:CompileThredhold认为设定。
当一个方法被调用，先检查是否存在被JIT编译过，如果存在，就调用本地代码，如果没有，就计数器+1，判读是否超过阈值，超过就给即时编译器提交赢该方法的代码编译请求，用解释方式执行方法。
如果不做任何设置，方法调用计数器统计的是相对次数，在一段时间的调用次数，当超过一定时间，如果方法的调用次数不足让即时编译器编译,哪这个方法的调用计数器就会减少一半,称为方法调用计数器热度衰减
这段时间称为此方法统计的班衰周期。进行热度衰减的动作实在垃圾收集时顺便进行的，使用-XX:-UserCounterDecay俩关闭热度衰减，-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是s。
回边计数器：-XX:BackEdgeThreshold设置，当前虚拟机为使用此参数，用-XX:OnStackReplacePercentage来简洁调整回边计数器的阈值：
Client：方法调用计数器阈值*OSR比率/100     13995
Server：方法调用计数器阈值*(OSR比率-解释器监控比率)/100            10700
使用过程与方法调用计数器差不多，有一点不同，就是回边计数器+1后跟阈值比对，超过阈值就提交OSR请求，并且把会变计数器的值降低一点，一遍继续在解释器中执行循环。
11.2.3编译过程
默认情况下，无论是方法调用产生的即时编译请求还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然按照解释方法执行，而编译动作则在后台的编译线程中进行。用户可以通过参数-XX:-BackgroundCompilation来禁止后台编译，如果执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。
对于Client Compiler来说，是一个简单快速的三段式编译器，主要的关注点在与局部性的优化，而放弃了许多耗时较长的全局优化手段。
第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示。
第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示，而在此之前会在HIR上完成另外一些优化，如空值检查消除，范围检查消除等，以便让HIR达到更高效的代码表示
最后阶段是在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上窥孔优化，产生机器代码











Server Compiler的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构上的大寄存器集合。它的编译速度远远超过静态优化编译器，而且相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销。
11.2.4查看及分析即时编译结果
要知道那个方法是否被编译过，可以使用参数-XX:+PrintCompilation要去虚拟机在即时编译时将编译成文本代码的方法名称打印出来。-XX:+PrintInlining要求虚拟机输出方法内联信息。
虚拟机安装反汇编适配器之后，可以使用-XX:+PrintAssembly参数要求虚拟机打印编译方法的汇编代码。
-XX:+PrintCFGToFile(Client Compiler)或-XX:PrintIdealGtaphFile(Server Compiler)让虚拟机将编译过程中各个阶段的数据输出到文件中(字节码，HIR,LIR,寄存器分配，本地代码等)
After Parsing这个阶段就是Server Compiler刚完成解析，还没有做任何优化的Ideal图表示，打开后，会有许多有颜色的方块，每一个方块就代表了一个程序的基本块，基本块的特点:只有唯一的一个入口和唯一的一个出口，只要基本块中的第一条指令执行了，那么所有执行都会按照顺序仅执行一次。

即时编译

解释器
Interperter

编译器
Client Compiler
Server Compiler

逆优化

字节码			HIR到LLR转换

方法内联			优化后的HIR
常量传播
其他优化…			空值检查消除
					范围检查消除
HIR(SSA形式)			其他优化…

LTR

寄存器分配
窥孔优化
机器码生成

本地代码

11.3编译优化技术

			
			 

方法内联：目的：1是去除方法调用的成本(如建立栈帧等)。2是为其他优化建立良好的基础，方法内联膨胀后可以便于在更大范围上采取后续的优化手段。
冗余访问消除：消除冗余，如果不改变数值，可以直接从上面赋值得到，不用访问对象，
复写传播：在逻辑上没有必要使用额外的变量
无用代码消除：完全没有意义的代码。
11.3.2公共子表达式消除
如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为了公共子表达式。没必要再次计算，只需要直接从前面计算过的表达式结果代替E就可以了。
如果优化仅限于程序的基本块内，便成为局部公共子表达式消除，如果优化范围涵盖多个基本块，称为全局公共子表达式消除。
11.3.3数组边界检查消除
如果编译器只要通过数据流分析就可以判断循环变量的取值范围，那么整个循环中就可以把数组的上下界检查消除，可以节省很多次的条件判断。
11.3.4方法内联
为了解决虚方法的内联问题，首先引入一种名为类型继承关系分析的技术，这是一种基于整个应用程序的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现，是否存在子类，等信息
编译器在进行内联时，如果是非虚方法，哪就直接内联。如果是虚方法，则会向CHA查询此方法在当前程序下是否有多个版本可供选择，如果只有一个版本，就进行内联，不过这种内联属于激进优化，要预留一个逃生门，称为守护内联。如果加载了导致继承关系发生变化的类，哪就抛弃已经编译的代码，回到解释状态执行，或者重新编译。如果是多个版本的目标方法选择，则编译器会使用内联缓存来完成方法内联，这是一个建立在目标方法正常入口之前的缓存，工作原理：在未发生方法调用过之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接受者版本，如果都一样，那这个内联还可以一直用下去，如果不一样，那就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。
11.3.5逃逸分析
分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸。甚至被外部线程访问到，称为线程逃逸。
如果能证明一个对象不会逃逸到方法或线程之外，则可能为这个变量进行一些高效的优化
	• 栈上分配:java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。如果确定一个对象不会逃逸出方法之外，那就让对象在栈上分配空间内存，对象所占用的内存就可以随栈帧出栈而销毁。
	• 同步消除:线程同步很耗时，如果确定一个变量不会逃逸出线程，无法被其他线程访问到，就对这个变量实施同步的措施可以消除掉
	• 标量替换:标量是指一个数据已经无法分解成更小的数据来表示，如果一个数据可以继续分解，称为聚合量，根据程序访问情况，将其使用到的成员变量恢复原始类型来访问称为标量替换。
	如果一个对象不会被外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不创建这个对象，而是改为直接创建它的若干个被这个方法使用的成员变量来替代。
使用-XX:+DoEscapeAnalysis来手动开启逃逸分析，通过-XX:+PrintEscapeAnalysis查看分析结果。
-XX:+EliminateAllocations来开启标量替换，-XX:+EliminateLocks来开启同步消除。
-XX:+PrintEliminateAllocations查看标量的替换情况。
