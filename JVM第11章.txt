当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为热点代码。为了提高热点代码的
效率，在运行时，虚拟机将会吧这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成任务的编译器称为即时编译器(JIT)。
11.2HotSpot虚拟机内的即时编译器
	• 为何HotSpot虚拟机要使用解释器与编译器并存的架构
	• 为何HotSpot虚拟机要实现两个不同的即时编译器
	• 程序何时使用解释器执行？何时使用编译器执行？
	• 那些程序代码会被编译为本地代码？如何编译为本地代码？
	• 如何从外部观察及时编译器的编译过程和编译结果？
11.2.1解释器与编译器
解释器与编译器各有优点;当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，繁殖可以使用编译执行来提高效率。








HotSpot虚拟机内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称C1,C2.
无论采用的编译器是哪个，解释器与编译器搭配使用的方式在虚拟机中称为混合模式，用户可以使用参数“-Xint”强制虚拟机运行与解释模式，这时候编译器完全不介入工作，全部diamante由解释方式执行。
或者使用参数“-Xcomp”强制虚拟机处于“编译模式”，使用“-version”显示着三种模式
为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译的策略，
分层编译根据编译器编译，优化的规模与耗时，划分出不同的编译层次
	• 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译
	• 第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑
	• 第2层（或2层以上），称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。
实行分层编译后，Client Compiler 和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Complier获取更高的编译速度，用Server Compiler类获取更好的编译指令，在解释执行的时候也无序在承担收集性能监控信息的任务。
11.2.2编译对象与触发条件
有两类被即时编译器编译的热点代码：被多次调用的方法，被多次执行的循环体。
对于第一种情况,由于是由方法调用触发的编译,因此编译器理所当然的会一整个方法作为编译对象,这种编译也是虚拟机中标准的JIT编译方式.对于后一种情况,尽管编译动作是由循环体所触发的,但编译器依然会以整个方法作为编译对象.这种编译方式因为编译发生在方法执行过程中,因此形象的称为栈上替换(OSR)
判断一段代码是不是热点代码，是不是需要出发即时编译，这样的行为成为热点探测，
	• 基于采样的热点探测：采用这种方法的虚拟机会周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，哪这个方法就是热点方法。
	• 基于计数器的热点探测：虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为是热点方法。
在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测，因此他为每个方法准备了两类计数器：方法调用计数器和回边计数器，都有确定的阈值，当计数器超过阈值，就会触发JIT编译。
方法调用计数器：默认值：Client 1500   Server  10000 通过-XX:CompileThredhold认为设定。
当一个方法被调用，先检查是否存在被JIT编译过，如果存在，就调用本地代码，如果没有，就计数器+1，判读是否超过阈值，超过就给即时编译器提交赢该方法的代码编译请求，用解释方式执行方法。
