对于一次IO访问，数据会先被拷贝到操作系统内核的缓冲区中，然后从操作系统内核的缓冲区拷贝到
应用程序的地址空间。
所以当发生IO操作的时候，会经历两个阶段：1、等待数据准备2、将数据从内核拷贝到进程中。
	1. 同步阻塞IO
	当用户进程调用IO时，操作系统就开始准备数据，当操作系统内核一直等到数据准备好，它就会将数据从操作系统内核中拷贝到用户内存中，然后返回结果，用户进程才解除锁住的状态，重新运作。整个过程需要等待，用户进程则相当于卡住等待返回结果
	特点：IO操作的两个阶段都被锁住了。
	2. 同步非阻塞IO(nonblocking IO)
	当用户进程调用IO时，在第一个阶段如果内核数据没有准备好，并不会锁住用户进程，而是立刻返回一个error。然后用户收到就知道没有准备好，就去问内核有没有准备好，直到内核准备好，并且收到了用户进程的询问，就会立刻拷贝数据，进行第二阶段(仍然会卡住，非阻塞IO只是在第一阶段非阻塞)
	特点：用户进程需要不断的询问kernel(内核)数据准备好没，效率不高
	3. I/O多路复用
	用户进程可以同时发多个网络连接IO，操作系统实施监控。
	内核发现进程指定的一个或多个IO条件就绪了，就通知进程。
	特点：性能可能比阻塞IO还要差，但他的优点在与能同时处理多个连接。所以，如果处理的连接数不是很高的话，使用IO多路复用不一定比使用多线程+阻塞IO的性能更好，可能延迟更大
	4. 信号驱动I/O
	特点：等操作系统数据准备好就通知进程，进程可以做自己的事。
	5. 异步非阻塞I/O
	当处理一个IO操作的时候，用户进程把数据传过来，操作系统会立即返回收到，用户进程就不用管了，可以做其他事情。等操作系统处理完两个阶段，就自动告诉用户进程处理完成。
	特点：用户进程完全把东西交给操作系统完成，自己不管。
