13.2线程安全
代码本身封装了所有必要的正确性保障手段，令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。
13.2.1java语言中的线程安全
将java语言中各种操作共享数据粪污5类：不可变，绝对线程安全，相对,线程兼容,线程对立
	1. 不可变：在java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要在采取任何的线程安全保证措施。
	java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰就可以保证不可变。如果是一个对象，哪就需要保证对象的行为不会对其状态产生任何影响才行。可以将对象中带有状态的变量声明为final，这样就不可变了。
	String，Enum，Long，Double等数值包装类型，BigInteger和BigDecimal等大数据
	2. 绝对线程安全：Vector是线程安全的，但不是绝对线程安全，Vector的add，size，get方法都是被synchronized修饰的，效率低，但是安全。在多线程的环境下，如果不在方法调用端做额外的同步措施的话，还可能不安全，因为如果另一个线程刚好在错误的时间内删除了一个元素，导致序号i不存在，要是访问i就会出错ArrayIndexOutOfBs
	3. 相对线程安全就是我们通常所讲的线程安全，需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段保证调用的正确性。
	java语言中大部分的线程安全类都属于这种类型,Vector,HashTable,Collections的synchronizedCollection()方法包装的集合等。
	4. 线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象的并发环境中可以安全的使用，我们平常说一个不是线程安全的，绝大多数时候指的是这一种情况，java API大部分的类都属于线程兼容的，如Vector和HashTable对应的集合类ArrayList和HashMap等。
	5. 线程对立：无理论调用端是否采用同步措施，都无法在多线程环境中并发使用的代码。
13.2.2线程安全的实现方法
	1. 互斥同步
	• 互斥同步是常见的一种并发正确性保障收单。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。临界区，互斥量，信号量都是主要的互斥实现方式，互斥是因，同步是过；互斥是方法，同步是目的。
	• 最基本的互斥同步手段就是synchronized关键字，经过编译后，会在同步块的前后分别形成monitorenter,monitorexit两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果java程序中synchronized明确指定了对象参数，哪就是这个对象的reference，如果没有明确指出，就根据synchronized修饰的实例方法或类方法区取对应的对象实例或Class对象作为锁对象。
	• 在执行monitorenter指令时，首先要尝试获取对象的锁，如果对象没有被锁定，或者当前已经由那个对象的锁，把锁计数器+1，执行monitorexit时所计数器-1，当计数器为0是，锁被释放。如果获取锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放。
	• synchronized同步块对同一条线程是可重入的，不会出现自己吧自己锁死的情况，其次，同步块在以进入的线程执行完之前，会阻塞后面其他线程的进入。阻塞或唤醒一个线程，都需要从用户态转换到和心态中，状态转换需要耗费很多的处理器时间。
	• 重量级，确实有必要才使用。
	• 使用java.util.concurrent包中的重入锁(ReentrantLock)来是吸纳同步，基本用法与synchronized相似，都具备线程重入特性，当一个线程获取锁时,还可以接着重复获取多次。相比synchronized增加了3个功能：等待可汇中断，可实现公平锁，锁可以绑定多个条件。
	• 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，
	• 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁。synchronized的锁时非公平的，ReentrantLock默认是非公平的，但是可以通过带布尔值的构造函数要求使用公平锁。
	• 锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象，只需要多次调用newConditon()方法即可。
	Condition接口在使用前必须先调用ReentrantLock的lock()方法获得锁。之后调用Condition接口的await()将释放锁,并且在该Condition上等待,直到有其他线程调用Condition的signal()方法唤醒线程。使用方式和wait,notify类似。
	2. 非阻塞同步
	互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。互斥同步属于一种悲观的并发策略，如果不做正确的同步措施，就会出现问题，无论共享数据是否会出现竞争，都要加锁
	• 基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程征用共享数据，哪操作成功，如果共享数据有征用，产生冲突，就采取其他的补偿措施(常见的补偿措施是被不断重试，知道成功)，这种乐观的并发策略的许多实现都不需要吧线程挂起，这种同步操作称为非阻塞同步。.多次操作的行为只通过一条指令：
		○ 测试并设置(Test-and-Set0
		○ 获取并增加(Fetch-and-Increment)
		○ 交换(Swap)
		○ 比较并交换(Compare-and-Swap    CAS)
		○ 加载链接/条件存储(Load-Linked/Store-Conditional   LL/SC)
	• CAS指令需要3个操作数，分别是内存位置(V)，旧的预期值(A)和新值(B)，CAS执行时，只有当V符合旧预期值A时，处理器用心智B更新V的值，否则它就不执行操作，但是无论是否更新了V的值，都会返回V的旧值，这个处理过程是原子操作。
	• ABA问题
	3. 无同步方案
	要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，哪它自然就无需同步
	• 可重入代码：这种代码也叫做纯代码，可以在代码执行的任何时刻中断它，转去执行另外一段代码(包括递归)，而在控制权返回后，原来程序不会出现任何错误。所有的可重入的代码都是线程安全的，但是线程安全的不一定可以重入。
	我们可以通过一个简单的原则判断是否具备可重入行：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，哪就满足可重入性的要求，当然也就是线程安全的。
	• 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，哪就看看这些共享数据的代码是否能保证在同一个线程中执行？如果你能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样就不会出现数据争用。

13.3锁优化
13.3.1自旋锁与自适应自旋
如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自旋)，这就称为自旋锁
默认关闭，使用-XX:+UserSpinning参数开启，自旋等待本身虽然避免了线程切换的开销，但是是占用处理器时间的。因此，自旋等待的时间必须要有一定的限度，如果自旋了限定的次数仍然没有成功获得锁，就应当使用户传统的方式去挂起线程了。自旋默认是10，用户可以使用参数-XX:PreBlockSpin来更改。
JDK1.6引入了自适应的自旋锁，自适应意味着自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
13.3.2锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。
13.3.3锁粗化
原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小---只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，哪等待锁的线程也能尽快拿到锁。
如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出啊先在循环体中的，哪即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。
13.4.4轻量级锁
轻量级锁时JDK1.6之中加入的新型锁机制，轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为重量级锁。轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用曹锁系统互斥量产生的性能消耗。
HotSpot虚拟机的对象头分为两部分：1、存储对象自身的运行时数据，是实现清零及锁和偏向锁的关键。(Mark Word)2、用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。


当代码进入同步块的时候，如果此同步对象没有被锁定(01)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功，那么这个线程就拥有了该对象的锁，并且对象的所标志位将转变为00，如果操作失败，虚拟机首先会检查对象的MW是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程征用同一个锁，哪轻量级锁不在有效，膨胀为中联机锁，标志位为10，后面等待锁的线程也要进入阻塞状态。
解锁过程是通过CAS操作来进行的，如果对象的MW仍然指向这线程的锁记录，哪就用CAS操作把对象当前的MW和线程中赋值的DMW提花回来，如果替换成功，整个同步完成了。如果失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。
13.3.5偏向锁
目的：消除数据在无竞争情况下的同步原语，进一步提高线程的运行性能。
如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，哪偏向锁就是在无竞争的情况下吧整个同步都消除掉，链CAS操作都不做。
偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步。
使用-XX:+UseBiasedLocking开启，当虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01，及偏向模式。同时使用CAS操作吧获取到这个锁的线程ID记录在对象的MW中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当灵一个线程去尝试获取这个锁，偏向模式宣告结束。根据锁目前是否处于被锁定的状态，撤销偏向后恢复到位锁定（01）或轻量级锁定（00）状态，后续的同步就根据轻量级锁进行。


